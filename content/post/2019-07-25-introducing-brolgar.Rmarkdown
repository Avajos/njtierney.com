---
title: Explore longitudinal data with brolgar
author: ''
date: '2019-07-25'
draft: true
slug: introducing-brolgar
categories:
  - ggplot2
  - rstats
  - Statistics
  - data visualisation
  - longitudinal data
  - panel data
tags:
  - rstats
---

Let's say we've managed to find an interesting dataset on heights for given countries since 1550 (yup):

```{r show-heights, echo = FALSE}
library(brolgar)
knitr::kable(head(heights))
```

We've got country, year, height (in centimetres), and continent. Neat!

Now, let's look at it over time.

```{r show-spaghetti, echo = FALSE, message = FALSE, warning = FALSE}
library(brolgar)
library(ggplot2)
ggplot(heights, 
       aes(x = year, 
             y = height_cm, 
             group = country)) + 
  geom_line()
```


Oh no.

This might seem familiar to you. Looking at longitudinal (panel) data often yields these kinds of "spaghetti" plots. These can be frustrating to deal with, as it is not clear how to see the right features in the data.

I've spent a fair bit of time this year with [Di Cook](http://dicook.org/) and also [Tania Prvan]() thinking about some ways to improve how we look at and explore longitudinal data. It is a hard problem, and I'm certainly not done yet, but we created the `brolgar` package to help make it easier to explore and visualise longitudinal data. 

Why the name `brolgar`? It is an acronym, standing for:

* **br**owse 
* **o**ver
* **l**ongitudinal 
* **d**ata 
* **g**raphically and 
* **a**nalytically in 
* **R**

It is so named after the "brolga", [a beautiful, gregarious (yes, gregarious!) native Australian crane](https://en.wikipedia.org/wiki/Brolga):

<p><a href="https://commons.wikimedia.org/wiki/File:Brolgas_Healesville.jpg#/media/File:Brolgas_Healesville.jpg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/32/Brolgas_Healesville.jpg/1200px-Brolgas_Healesville.jpg" alt="Brolgas Healesville.jpg"></a><br>By Felix Andrews (<a href="//commons.wikimedia.org/wiki/User:Floybix" title="User:Floybix">Floybix</a>) - <span class="int-own-work" lang="en">Own work</span>, <a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=1116364">Link</a></p>

Similar to our work on missing data with the [`naniar`]() package, we wanted `brolgar` to work well with existing packages in the [`tidyverse`](), with particular focus on `dplyr` and `ggplot2`.

I'll direct you to the [official brolgar website](http://brolgar.njtierney.com/) for more details on the package, but here I will showcase three ideas that I think make workflow significantly more efficient, and help you learn from your data.

* Idea 1: Longitudinal data is a time series
* Idea 2: Explore by taking samples
* Idea 3: Finding interesting features

# Idea 1: Longitudinal data is a time series

But not your typical time series - it generally has irregular amounts of time between measurements.

To efficiently look at your longitudinal data, we assume it **is a time series**, with irregular time periods between measurements. This might seem strange, (that's OK!), but there are **two important things** to remember:

1. The **key** variable in your data is the **identifier** of your individuals or series.
2. The **index** variable is the **time** component of your data.

Together, the **index** and **key** uniquely identify an observation.

The term `key` is used a lot in brolgar, so it is an important idea to internalise:

> **The key is the identifier of your individuals or series**

So in the `heights` data, we have the following setup:

```{r setup-height-ts, eval = FALSE}
heights <- as_tsibble(x = heights,
                      key = countries,
                      index = year,
                      regular = FALSE)
```

```{r print-heights}
heights
```


Once we consider our longitudinal data a time series, we gain access to a set of amazing tools from the [`tidyverts` team](https://tidyverts.org/). What this means is that now that we know what your **time index** is, and what represents **each series with a key**, we can use that information to make sure we respect the structure in the data. This means you can spend more time performing analysis, and using functions fluently, and less time remembering to tell R about the structure of your data. 

If you want to learn more about longitudinal data as a time series, you can [read more in the vignette, "Longitudinal Data Structures"](library/brolgar/html/longitudinal-data-structures.html)

# Idea 2: Explore by taking samples

To get a sense of what your data is, you can sometimes get something out of looking at a small sample. We've got some really neat tools for that.

## Sample with `sample_n_keys()` 

In `dplyr`, you can use `sample_n()` to sample `n` observations. Similarly, with `brolgar`, you can take a random sample of `n` keys using `sample_n_keys()`, or take a fraction (just as in `dplyr::sample_frac()`), using `sample_frac_keys()`, which samples a fraction of available keys.


```{r plot-sample-n-keys}
library(brolgar)
library(ggplot2)
# seed set for reproducibility
set.seed(2019-08-07)
heights %>%
  sample_n_keys(size = 10) %>%
  ggplot(aes(x = year,
             y = height_cm,
             group = country)) + 
  geom_line()
```


OK so now we can see that for this small sample, it looks like they heights are generally increasing over time, but there is some pretty massive fluctuation as well!

## Filtering observations by number of observations

You can calculate the number of observations for each key with `add_n_obs()`:

```{r add-n-obs}
add_n_obs(heights)
```


This means you can combine `add_n_obs()` and `sample_n_keys()` with `filter()` to filter keys with say, greater than 5 observations:

```{r plot-filter-sample-n-keys}
# set seed for reproducibility
set.seed(2019-08-07)
library(dplyr)
heights %>%
  add_n_obs() %>%
  filter(n_obs > 5) %>%
  sample_n_keys(size = 10) %>%
  ggplot(aes(x = year,
             y = height_cm,
             group = country)) + 
  geom_line()
```


It looks like we have a bit of a mixed bag in terms of some countries increasing a lot over time, and others not so much.

Can we break these into many plots?

## Sample with `facet_sample()`

`facet_sample()` allows you to specify the number of keys per facet, and the number of facets with `n_per_facet` and `n_facets`. By default, it splits the data into 12 facets with 5 per facet:

```{r facet-sample}
# set seed for reproducibility
set.seed(2019-08-07)

ggplot(heights,
       aes(x = year,
           y = height_cm,
           group = country)) +
  geom_line() +
  facet_sample()

```

Interesting - looks again like many inreasing, but there is some variation and some serious wiggliness!

You can specify your own number of lines per plot and number of facets. Let's say 3 per facet, and 20 facets:

```{r facet-sample-3-by-20}
# set seed for reproducibility
set.seed(2019-08-07)

ggplot(heights,
       aes(x = year,
           y = height_cm,
           group = country)) +
  geom_line() +
  facet_sample(n_per_facet = 3,
               n_facets = 20)

```


# Idea 3: Finding interesting features

In order to find interesting features, there are two steps:

1. Reduce each series (`key`) down to a one-row summary of features.
2. _join_ this series back to the regular data. 

## 1. Find features with `features()`

You can extract `features()` of longitudinal data using the `features()` function, from `fablelite`. You can, for example, calculate the minimum of a given variable for each key by providing a named list like so:

```{r features-min}
heights %>%
  features(height_cm, 
           list(min = min))
```

`brolgar` provides some sets of features, which start with `feat_`.

For example, the five number summary is `feat_five_num`:

```{r features-five-num}
heights %>%
  features(height_cm, feat_five_num)
```

Or finding those whose values only increase or decrease with `feat_monotonic`

```{r features-monotonic}
heights %>%
  features(height_cm, feat_monotonic)
```

You can read more about creating your own features in the vignette [creating features](http://brolgar.njtierney.com/articles/creating-features.html).

## 2. Joining individuals back to the data

You can join these features back to the data with `left_join`, like so:

```{r features-left-join}
library(dplyr)
heights_mono <- heights %>%
  features(height_cm, feat_monotonic) %>%
  left_join(heights, by = "country")

heights_mono
```

You can then plot them with the amazing [`gghighlight` package by Hiroaki Yutani](https://github.com/yutannihilation/gghighlight) to highlight interesting parts of a plot.

For example, one that highlights only those keys that are increasing:

```{r features-mono}
library(gghighlight)
ggplot(heights_mono,
       aes(x = year,
           y = height_cm,
             group = country)) +
  geom_line() + 
  gghighlight(increase)
```

## Fit a linear model for each key using `key_slope()`

`key_slope()` returns the intercept and slope estimate for each key, given some linear model formula. We can get the number of observations, and slope information for each key to identify those changing over time. 

```{r use-key-slope}
height_slope <- key_slope(heights, height_cm ~ year)

height_slope
```

Then joing this back:

```{r slope-left-join}
heights_slope <- heights %>%
  key_slope(height_cm ~ year) %>%
  left_join(heights, by = "country")

heights_slope
```

And highlight those with a negative slope:

```{r gghighlight-slope}
ggplot(heights_slope,
       aes(x = year,
           y = height_cm,
           group = country)) +
  geom_line() + 
  gghighlight(.slope_year < 0)
```


## Facet along some feature:

You can even facet _along_ some feature, using `facet_strata(along = var)`. For example, we could facet our data along the slope. `facet_strata` requires a `tsibble` object, so we need to be careful with how we do our join.

```{r facet-strata-along}
heights %>%
  key_slope(height_cm ~ year) %>%
  left_join(x = heights, 
            y = ., 
            by = "country") %>% 
ggplot(aes(x = year,
           y = height_cm,
           group = country)) +
  geom_line() + 
  facet_strata(n_strata = 12,
               along = .slope_year)
```

This shows us the spread of countries when we break slop up into 12 groups arranged in order from increasing to decreasing slope.

Under the hood, `facet_strata()` and `facet_sample()` are powered by [`sample_n_keys()`](http://brolgar.njtierney.com/reference/sample-n-frac-keys.html) and [`stratify_keys()`](http://brolgar.njtierney.com/reference/stratify_keys.html), I've linked to their documentation online in the text.

## Find keys near some summary statistic with `keys_near()`

If you want to take the slope information and only return those individuals closest to the five number summary of slope - say those closest to these values:

```{r keys-near-summary}
summary(heights_slope$.slope_year)
```

You can find those keys near the minimum, 1st quantile, median, mean, 3rd quantile maximum, using `keys_near()`, specifying the `country` and `.slope_year`.

```{r keys-near}
heights_near <- heights %>%
  key_slope(height_cm ~ year) %>%
  keys_near(key = country,
            var = .slope_year)

heights_near
```

This returns those keys closest to some statistics.

You could include it in a plot like so:

```{r keys-near-plot}

heights_near %>%
  left_join(heights, by = "country") %>%
ggplot(aes(x = year,
           y = height_cm,
           colour = stat)) + 
  geom_line() 
  
```

You can read more about `keys_near()` at the [finding summary keys vignette](http://brolgar.njtierney.com/articles/find-summary-keys.html).

# Fin

There is more to come for `brolgar` - the API will be likely to change as I get feedback from the community, and as I think and learn more about exploring longitudinal data. You can see my current thoughts on what to include in `brolgar` in [the brolgar issues](https://github.com/njtierney/brolgar/issues).

If you have any thoughts, comments, problems, or concerns, post a comment below or even better [file an issue](https://github.com/njtierney/brolgar/issues/new).

Happy data exploring!
