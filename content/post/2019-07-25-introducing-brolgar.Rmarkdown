---
title: Explore longitudinal data with brolgar
author: ''
date: '2019-07-25'
draft: true
slug: introducing-brolgar
categories:
  - ggplot2
  - rstats
  - Statistics
  - data visualisation
  - longitudinal data
  - panel data
tags:
  - rstats
---

Looking at longitudinal data often yields something like the following:

```{r show-spaghetti, echo = FALSE, message = FALSE, warning = FALSE}
library(brolgar)
library(ggplot2)
ggplot(heights, 
       aes(x = year, 
             y = height_cm, 
             group = country)) + 
  geom_line()
```


These can be frustrating to deal with, as it is not clear how to see the right features in the data.

I've spent a fair bit of time this year with [Di Cook](http://dicook.org/) thinking about some ways to improve how we look at and explore longitudinal data. It is a hard problem, and I'm certainly not done yet, but we created the `brolgar` package to help make it easier to explore and visualise longitudinal data. 

Why the name `brolgar`? It is an acronym, standing for:

* **br**owse 
* **o**ver
* **l**ongitudinal 
* **d**ata 
* **g**raphically and 
* **a**nalytically in 
* **R**

It is so named after the "brolga", [a beautiful, gregarious native Australian crane](https://en.wikipedia.org/wiki/Brolga):

<p><a href="https://commons.wikimedia.org/wiki/File:Brolgas_Healesville.jpg#/media/File:Brolgas_Healesville.jpg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/32/Brolgas_Healesville.jpg/1200px-Brolgas_Healesville.jpg" alt="Brolgas Healesville.jpg"></a><br>By Felix Andrews (<a href="//commons.wikimedia.org/wiki/User:Floybix" title="User:Floybix">Floybix</a>) - <span class="int-own-work" lang="en">Own work</span>, <a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=1116364">Link</a></p>


I'll direct you to the [official brolgar website](http://brolgar.njtierney.com/) for more details on the package, but here I will showcase three ideas that I think make workflow significantly more efficient:

* Idea 1: Longitudinal data is a time series
* Idea 2: Explore by taking samples
* Idea 3: Finding interesting features

# Idea 1: Longitudinal data is a time series

To efficiently look at your longitudinal data, we assume it **is a time series**, with irregular time periods between measurements. This might seem strange, (that's OK!), but there are **two important things** to remember:

1. The **key** variable in your data is the **identifier** of your individuals or series.
2. The **index** variable is the **time** component of your data.

Together, the **index** and **key** uniquely identify an observation.

The term `key` is used a lot in brolgar, so it is an important idea to internalise:

> **The key is the identifier of your individuals or series**


So in the `heights` data, we have the following setup:

```{r setup-height-ts, eval = FALSE}
heights <- as_tsibble(x = heights,
                            key = countries,
                            index = year,
                            regular = FALSE)
```

```{r print-heights}
heights
```


Once we consider our longitudinal data a time series, we gain access to a set of amazing tools from the [`tidyverts` team](https://tidyverts.org/). What this means is that now that we know what your **time index** is, and what represents **each series with a key**, we can use that information to make sure we respect the structure in the data. This means you can spend more time performing analysis, and using functions fluently, and less time remembering to tell R about the structure of your data. 

If you want to learn more about longitudinal data as a time series, you can [read more in the vignette, "Longitudinal Data Structures"](library/brolgar/html/longitudinal-data-structures.html)


# Idea 2: Explore by taking samples

To get a sense of what your data is, you sometimes just need to look at a small sample. We've got some really neat tools for that.

## Sample with `sample_n_keys()` 

In `dplyr`, you can use `sample_n()` to sample `n` observations. Similarly, with `brolgar`, you can take a random sample of `n` keys using `sample_n_keys()`:

```{r plot-sample-n-keys}
library(brolgar)
library(ggplot2)
heights %>%
  sample_n_keys(size = 10) %>%
  ggplot(aes(x = year,
             y = height_cm,
             group = country)) + 
  geom_line()
```

## Filtering observations with `filter_n_obs()`

You can combine `sample_n_keys()` with `filter_n_obs` to filter keys with many observations:

```{r plot-filter-sample-n-keys}
heights %>%
  filter_n_obs(n_obs > 5) %>%
  sample_n_keys(size = 10) %>%
  ggplot(aes(x = year,
             y = height_cm,
             group = country)) + 
  geom_line()
```

Similar to `dplyr::sample_frac()`, there is also `sample_frac_keys()`, which samples a fraction of available keys.

Now, how do you break these into many plots?

## Sample with `facet_sample()`

`facet_sample()` allows you to specify the number of keys per facet, and the number of facets with `n_per_facet` and `n_facets`. It splits the data into 12 facets with 5 per facet by default:

```{r facet-sample}
ggplot(heights,
       aes(x = year,
           y = height_cm,
           group = country)) +
  geom_line() +
  facet_sample()

```

But you can specify your own number:

```{r facet-sample-3-by-20}
ggplot(heights,
       aes(x = year,
           y = height_cm,
           group = country)) +
  geom_line() +
  facet_sample(n_per_facet = 3,
               n_facets = 20)

```


# Idea 3: Finding interesting features

In order to find interesting features, you need to reduce each series, or `key` down to a one-row summary table, and then _join_ this back to the regular data. This workflow is now demonstrated.

## Find features with `features()`

You can extract `features` of longitudinal data using the `features` function, from `fablelite`. You can, for example, calculate the minimum of a given variable for each key by providing a named list like so:

```{r features-min}
heights %>%
  features(height_cm, 
           list(min = min))
```

`brolgar` provides some sets of features, which start with `feat_`.

For example, the five number summary is `feat_five_num`:

```{r features-five-num}
heights %>%
  features(height_cm, feat_five_num)
```

Or finding those whose values only increase or decrease with `feat_monotonic`

```{r features-monotonic}
heights %>%
  features(height_cm, feat_monotonic)
```

You can read more about creating your own features in the vignette [creating features](http://brolgar.njtierney.com/articles/creating-features.html).

## Fit a linear model with `key_slope()`

`key_slope()` returns the intercept and slope estimate for each key, given some linear model formula. We can get the number of observations, and slope information for each key to identify those changing over time. 

```{r use-key-slope}
height_slope <- key_slope(heights, height_cm ~ year)

height_slope
```

## Linking individuals back to the data

You can join these features back to the data with `left_join`, like so:

```{r features-left-join}
library(dplyr)
heights_mono <- heights %>%
  features(height_cm, feat_monotonic) %>%
  left_join(heights, by = "country")

heights_mono
```

Or for the linear model data:

```{r slope-left-join}
heights_slope <- heights %>%
  key_slope(height_cm ~ year) %>%
  left_join(heights, by = "country")

heights_slope
```

You can then plot them with the amazing [`gghighlight` package by Hiroaki Yutani](https://github.com/yutannihilation/gghighlight) to highlight interesting parts of a plot.

For example, one that highlights only those keys that are increasing:

```{r features-mono}
library(gghighlight)
ggplot(heights_mono,
       aes(x = year,
           y = height_cm,
             group = country)) +
  geom_line() + 
  gghighlight(increase)
```

Or those with a negative slope:

```{r gghighlight-slope}
ggplot(heights_slope,
       aes(x = year,
           y = height_cm,
           group = country)) +
  geom_line() + 
  gghighlight(.slope_year < 0)
```


## Facet along some feature:

You can even facet _along_ some feature, using `facet_strata(along = var)`. For example, we could facet our data along the slope. `facet_strata` requires a `tsibble` object, so we need to be careful with how we do our join.

```{r facet-strata-along}
heights %>%
  key_slope(height_cm ~ year) %>%
  left_join(x = heights, 
            y = ., 
            by = "country") %>% 
ggplot(aes(x = year,
           y = height_cm,
           group = country)) +
  geom_line() + 
  facet_strata(n_strata = 12,
               along = .slope_year)
```

This shows us the spread of countries when we break slop up into 12 groups arranged in order from increasing to decreasing slope.

Under the hood, `facet_strata()` and `facet_sample()` are powered by [`sample_n_keys()`](http://brolgar.njtierney.com/reference/sample-n-frac-keys.html) and [`stratify_keys()`](http://brolgar.njtierney.com/reference/stratify_keys.html), I've linked to their documentation online in the text.

## Find keys near some summary statistic

If you want to take the slope information and only return those individuals closest to the five number summary of slope - say those closest to these values:

```{r keys-near-summary}
summary(heights_slope$.slope_year)
```

You can find those keys near the minimum, 1st quantile, median, mean, 3rd quantile maximum, using `keys_near()`, specifying the `country` and `.slope_year`.

```{r keys-near}
heights_near <- heights %>%
  key_slope(height_cm ~ year) %>%
  keys_near(key = country,
            var = .slope_year)

heights_near
```

This returns those keys closest to some statistics.

You could include it in a plot like so:

```{r keys-near-plot}
heights_near %>%
  left_join(heights, by = "country") %>%
ggplot(aes(x = year,
           y = height_cm,
           colour = stat)) + 
  geom_line() 
  
```

You can read more about `keys_near()` at the [finding summary keys vignette](http://brolgar.njtierney.com/articles/find-summary-keys.html).

# Fin

There is more to come for `brolgar` - the API will be likely to change as I get feedback from the community, and as I think and learn more about exploring longitudinal data. You can see my current thoughts on what to include in `brolgar` in [the brolgar issues](https://github.com/njtierney/brolgar).

If you have any thoughts, comments, problems, or concerns, post a comment below or even better [file an issue](https://github.com/njtierney/brolgar/issues/new).

Happy data exploring!
